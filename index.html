<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ssj1314.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="书中自有颜如玉">
<meta property="og:type" content="website">
<meta property="og:title" content="葫芦小金刚">
<meta property="og:url" content="https://ssj1314.github.io/index.html">
<meta property="og:site_name" content="葫芦小金刚">
<meta property="og:description" content="书中自有颜如玉">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="大福禄">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ssj1314.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>葫芦小金刚</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">葫芦小金刚</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">宋帅杰</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">大福禄</p>
  <div class="site-description" itemprop="description">书中自有颜如玉</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2023/02/06/%E9%80%9A%E7%9F%A5%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/06/%E9%80%9A%E7%9F%A5%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">通知总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-06 11:12:25" itemprop="dateCreated datePublished" datetime="2023-02-06T11:12:25+08:00">2023-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-03 16:12:33" itemprop="dateModified" datetime="2023-04-03T16:12:33+08:00">2023-04-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904082516213768#heading-4">一文全解iOS通知机制(经典收藏)</a><br><a target="_blank" rel="noopener" href="https://github.com/gnustep/libs-base/blob/master/Source/GSArray.m">GNUStep</a>虽然不是苹果官方的源码，但很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计 </p>
<h3 id="1-实现原理（结构设计、通知如何存储的、name-amp-observer-amp-SEL）之间的关系等"><a href="#1-实现原理（结构设计、通知如何存储的、name-amp-observer-amp-SEL）之间的关系等" class="headerlink" title="1.实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL）之间的关系等"></a>1.实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL）之间的关系等</h3><h5 id="关键类结构"><a href="#关键类结构" class="headerlink" title="关键类结构"></a>关键类结构</h5><h5 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/****************	Notifications	****************/</span><br><span class="line"></span><br><span class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (readonly, copy) NSNotificationName name;</span><br><span class="line">@property (nullable, readonly, retain) id object;</span><br><span class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</span><br></pre></td></tr></tbody></table></figure>
<p>一般用于发送通知使用，常用API如下：<br>-(void)postNotification:(NSNotification*)notification;</p>
<h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><p>这是个单例类，负责管理通知的创建和发送，属于最核心的类。而NSNotificationCenter类主要负责三件事：<br>1.添加通知<br>2.发送通知<br>3.移除通知<br>核心 API 如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@property (class, readonly, strong) NSNotificationCenter *defaultCenter;</span><br><span class="line">//添加</span><br><span class="line">- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">//发送通知</span><br><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</span><br><span class="line">//删除通知</span><br><span class="line">- (void)removeObserver:(id)observer;</span><br><span class="line">- (void)removeObserver:(id)observer name:(nullable NSNotificationName)aName object:(nullable id)anObject;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h4><h5 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h5><p>通知队列，用于异步发送消息，这个异步并不开启线程，而是把通知存储在双向队列实现的队列里面，等待某个时机触发时调用NSNotificationCenter的发送接口发送通知，这么看NSNotifacationQueue最终还是调用NSNotificationCenter进行消息的分发。</p>
<p>通知是结构体通过双向链表进行数据存储</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl {</span><br><span class="line">  Observation       *wildcard;  /* 链表结构，保存既没有name也没有object的通知 */</span><br><span class="line">  GSIMapTable       nameless;   /* 存储没有name但是有object的通知 */</span><br><span class="line">  GSIMapTable       named;      /* 存储带有name的通知，不管有没有object  */</span><br><span class="line">    ...</span><br><span class="line">} NCTable;</span><br><span class="line">                                                                            </span><br><span class="line"></span><br><span class="line">// Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef struct  Obs {</span><br><span class="line">  id        observer;   /* 观察者，接收通知的对象  */</span><br><span class="line">  SEL       selector;   /* 响应方法     */</span><br><span class="line">  struct Obs    *next;      /* Next item in linked list.    */</span><br><span class="line">  ...</span><br><span class="line">} Observation;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="主要是以Key-Value的形式存储，这里强调一下，通知是以-name和object两个维度来存储通知的相关内容，"><a href="#主要是以Key-Value的形式存储，这里强调一下，通知是以-name和object两个维度来存储通知的相关内容，" class="headerlink" title="主要是以Key Value的形式存储，这里强调一下，通知是以 name和object两个维度来存储通知的相关内容，"></a>主要是以<font color="#0000ff">Key Value</font>的形式存储，这里强调一下，通知是以 <font color="fe323d">name</font>和<font color="fe323d">object</font>两个维度来存储通知的相关内容，</h4><p> <img src="https://upload-images.jianshu.io/upload_images/13277235-d1cdd2ef99a5c864.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="named表（mapTable)"><br> <img src="https://upload-images.jianshu.io/upload_images/13277235-b25d70e69f5cb196.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt="nameless表（mapTable)"></p>
<p>简单理解就是<font color="fe323d"><strong>name</strong>&amp;<strong>observer</strong>&amp;<strong>SEL</strong></font>之间的关联，就是<font color="fe323d">name</font>作为<font color="fe323d">key</font>，<font color="fe323d">observer</font>作为观察者对象，当合适的时候调用<font color="fe323d">observer</font>的<font color="fe323d">SEL</font>。</p>
<h3 id="2-通知的发送是同步的？还是异步的？"><a href="#2-通知的发送是同步的？还是异步的？" class="headerlink" title="2.通知的发送是同步的？还是异步的？"></a>2.通知的发送是同步的？还是异步的？</h3><p>同步发送，因为要调用消息转发。所谓异步，指的是非实时发送而是在<strong>合适的时机发送</strong>，并没有开启异步线程。</p>
<h3 id="3-NSNotificationCenter-接受消息和发送消息是一个线程里吗？如何异步发送消息？"><a href="#3-NSNotificationCenter-接受消息和发送消息是一个线程里吗？如何异步发送消息？" class="headerlink" title="3.NSNotificationCenter 接受消息和发送消息是一个线程里吗？如何异步发送消息？"></a>3.NSNotificationCenter 接受消息和发送消息是一个线程里吗？如何异步发送消息？</h3><p>是的，异步线程发送通知则响应函数也在异步线程。<br>异步发送通知可以开启异步线程发送即可。</p>
<h3 id="4-NSNotificationQueue是异步还是同步发送？在哪个线程响应？"><a href="#4-NSNotificationQueue是异步还是同步发送？在哪个线程响应？" class="headerlink" title="4.NSNotificationQueue是异步还是同步发送？在哪个线程响应？"></a>4.NSNotificationQueue是异步还是同步发送？在哪个线程响应？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) {</span><br><span class="line">    NSPostWhenIdle = 1, // runloop空闲时发送通知</span><br><span class="line">    NSPostASAP = 2, // 尽快发送，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow = 3 // 立刻发送或者合并通知完成之后发送</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">NSPostWhenIdle</th>
<th align="center">NSPostASAP</th>
<th align="right">NSPostNow</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NSPostingStyle</td>
<td align="center">异步发送</td>
<td align="center">异步发送</td>
<td align="right">同步发送</td>
</tr>
</tbody></table>
<p><font color="fe323d">NSNotifacationCenter</font>都是同步发送的，而<font color="fe323d">NSNotifacationQueue</font>的异步发送，从线程角度看并不是真正的异步发送，或可称之为延时发送，它是利用了<strong>runloop</strong>的时机来触发的。</p>
<h3 id="5-NSNotifacationQueue和RunLoop的关系"><a href="#5-NSNotifacationQueue和RunLoop的关系" class="headerlink" title="5.NSNotifacationQueue和RunLoop的关系"></a>5.NSNotifacationQueue和RunLoop的关系</h3><p><font color="fe323d">NSNotificationQueue</font>依赖<font color="fe323d">runloop</font>.因为通知队列要在<em>runloop</em>回调的某个时机调用通知中心发送通知，从它的枚举值可以看出来。</p>
<h3 id="6-如何保证通知接收的线程在主线程？"><a href="#6-如何保证通知接收的线程在主线程？" class="headerlink" title="6.如何保证通知接收的线程在主线程？"></a>6.如何保证通知接收的线程在主线程？</h3><p>有两种方式：<br>1.系统接受通知的API指定队列。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block</span><br></pre></td></tr></tbody></table></figure>
<p>2.<strong>NSMachPort</strong>的方式。通过在主线程的runloop中添加machPort，设置这个port的delegate，通过这个Port其他线程可以跟主线程通信，在这个port的代理回调中执行的代码肯定在主线程中运行，所以，在这里调用NSNotificationCenter发送通知即可</p>
<h3 id="7-页面销毁时不移除通知会崩溃吗？"><a href="#7-页面销毁时不移除通知会崩溃吗？" class="headerlink" title="7.页面销毁时不移除通知会崩溃吗？"></a>7.页面销毁时不移除通知会崩溃吗？</h3><p>iOS9.0之前，会crash，原因：通知中心对观察者的引用是unsafe_unretained，导致当观察者释放的时候，观察者的指针值并不为nil，出现野指针.</p>
<p>iOS9.0之后，不会crash，原因：通知中心对观察者的引用是weak。</p>
<h3 id="8-多次添加同一个通知会有什么结果？多次移除通知呢？"><a href="#8-多次添加同一个通知会有什么结果？多次移除通知呢？" class="headerlink" title="8.多次添加同一个通知会有什么结果？多次移除通知呢？"></a>8.多次添加同一个通知会有什么结果？多次移除通知呢？</h3><p>多次添加同一个通知，会导致发送一次这个通知的时候，响应多次通知回调。 多次移除通知不会产生crash。</p>
<h3 id="9-下面的代码方式能接受到通知吗？为什么"><a href="#9-下面的代码方式能接受到通知吗？为什么" class="headerlink" title="9.下面的代码方式能接受到通知吗？为什么"></a>9.下面的代码方式能接受到通知吗？为什么</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@"TestNotification" object:@1];</span><br><span class="line">// 接收通知</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@"TestNotification" object:nil];</span><br></pre></td></tr></tbody></table></figure>
<p>不能</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2023/02/01/swift%E5%92%8Coc%E6%B7%B7%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/01/swift%E5%92%8Coc%E6%B7%B7%E7%BC%96/" class="post-title-link" itemprop="url">swift和oc混编</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-02-01 09:49:04 / 修改时间：15:18:18" itemprop="dateCreated datePublished" datetime="2023-02-01T09:49:04+08:00">2023-02-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>###预编译知识指北</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/11/23/ios-%E5%85%A8%E5%B1%8F%E9%97%AE%E9%A2%98flutter-ios%E6%B7%B7%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/23/ios-%E5%85%A8%E5%B1%8F%E9%97%AE%E9%A2%98flutter-ios%E6%B7%B7%E7%BC%96/" class="post-title-link" itemprop="url">ios-全屏问题flutter-ios混编</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-11-23 13:47:57 / 修改时间：14:38:52" itemprop="dateCreated datePublished" datetime="2022-11-23T13:47:57+08:00">2022-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="最近在做FlutterViewController和iOS混编，项目绝大部分需要竖屏，且不随设备翻转变换方向，flutter插件中的better-player全屏需要屏幕支持横屏，因为flutterView所有的widget都在本身上，所以不能定位到视频界面，只能在viewwillapper中判断。"><a href="#最近在做FlutterViewController和iOS混编，项目绝大部分需要竖屏，且不随设备翻转变换方向，flutter插件中的better-player全屏需要屏幕支持横屏，因为flutterView所有的widget都在本身上，所以不能定位到视频界面，只能在viewwillapper中判断。" class="headerlink" title="最近在做FlutterViewController和iOS混编，项目绝大部分需要竖屏，且不随设备翻转变换方向，flutter插件中的better_player全屏需要屏幕支持横屏，因为flutterView所有的widget都在本身上，所以不能定位到视频界面，只能在viewwillapper中判断。"></a>最近在做FlutterViewController和iOS混编，项目绝大部分需要竖屏，且不随设备翻转变换方向，flutter插件中的better_player全屏需要屏幕支持横屏，因为flutterView所有的widget都在本身上，所以不能定位到视频界面，只能在viewwillapper中判断。</h2><blockquote>
<p>ps：本来想在pop返回之后做个监听，是视频页返回主页面的时候把屏幕再限定为竖屏，didMoveToParentViewController这些方法什么的，但flutterController就一层没法监听。</p>
</blockquote>
<h4 id="1-Deployment-Info设置项目设备屏幕旋转方向，这其实不能完全决定旋转方向"><a href="#1-Deployment-Info设置项目设备屏幕旋转方向，这其实不能完全决定旋转方向" class="headerlink" title="1.Deployment Info设置项目设备屏幕旋转方向，这其实不能完全决定旋转方向"></a>1.Deployment Info设置项目设备屏幕旋转方向，这其实不能完全决定旋转方向</h4><p><img src="https://upload-images.jianshu.io/upload_images/1761100-48f72fa19af9cfbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DeploymentInfo.png"></p>
<h4 id="2-在AppDelegate中设置，优先级更高的方法，如果这个方法实现，覆盖info中设置"><a href="#2-在AppDelegate中设置，优先级更高的方法，如果这个方法实现，覆盖info中设置" class="headerlink" title="2.在AppDelegate中设置，优先级更高的方法，如果这个方法实现，覆盖info中设置"></a>2.在AppDelegate中设置，优先级更高的方法，如果这个方法实现，覆盖info中设置</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) UIWindow *window;</span><br><span class="line">/***是否允许横屏的标记*/</span><br><span class="line">@property (nonatomic, assign) BOOL allowRotation;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">----------------------AppDelegate.m</span><br><span class="line">-(UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window</span><br><span class="line">{</span><br><span class="line">    if (self.allowRotation) {</span><br><span class="line">        return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscape;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    return UIInterfaceOrientationMaskPortrait;//默认不支持横屏</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-在UIViewController中"><a href="#3-在UIViewController中" class="headerlink" title="3.在UIViewController中"></a>3.在UIViewController中</h4><p>当设备发生旋转时，首先会查看根controller的shouldAutorotate是否允许旋转，如果允许，再通过<br>supportedInterfaceOrientations返回的方向 和 系统支持的方向 的交集，判断当前这个旋转是否应该发生。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 屏幕旋转这三个方法可以在原生正常viewController中起效，对flutterViewController不起作用</span><br><span class="line">///屏幕是否可以选择，yes</span><br><span class="line">- (BOOL)shouldAutorotate {</span><br><span class="line">    return YES;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">///页面选择默认方向</span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {</span><br><span class="line">    return UIInterfaceOrientationLandscapeRight;</span><br><span class="line">}</span><br><span class="line">//页面支持的旋转方向</span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations {</span><br><span class="line">    return UIInterfaceOrientationMaskLandscape;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------设置支持旋转方向+退出界面关闭，可在viewwillapper中调用------</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated {</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    if (self.isPop)</span><br><span class="line">    {</span><br><span class="line">        [self endFullScreen];</span><br><span class="line">        self.isPop = !self.isPop;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">------------------------------------------------</span><br><span class="line">//进入全屏</span><br><span class="line">-(void)begainFullScreen{</span><br><span class="line">    _isPop = YES;</span><br><span class="line">  AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];</span><br><span class="line">  appDelegate.allowRotation = YES;</span><br><span class="line">}</span><br><span class="line">// 退出全屏</span><br><span class="line">-(void)endFullScreen{</span><br><span class="line">  AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];</span><br><span class="line">  appDelegate.allowRotation = NO;</span><br><span class="line">  //强制归正：</span><br><span class="line">  if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {</span><br><span class="line">    SEL selector = NSSelectorFromString(@"setOrientation:");</span><br><span class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</span><br><span class="line">    [invocation setSelector:selector];</span><br><span class="line">    [invocation setTarget:[UIDevice currentDevice]];</span><br><span class="line">    int val =UIInterfaceOrientationPortrait;</span><br><span class="line">    [invocation setArgument:&amp;val atIndex:2];</span><br><span class="line">    [invocation invoke];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="PS-提示-想监听侧滑返回结果，用下面的方法，但这个在混编项目里不适用，因为flutter只有一个树"><a href="#PS-提示-想监听侧滑返回结果，用下面的方法，但这个在混编项目里不适用，因为flutter只有一个树" class="headerlink" title="PS:提示 想监听侧滑返回结果，用下面的方法，但这个在混编项目里不适用，因为flutter只有一个树"></a>PS:提示 想监听侧滑返回结果，用下面的方法，但这个在混编项目里不适用，因为flutter只有一个树</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidDisappear:(BOOL)animated {</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">    if (self.navigationController == nil) {</span><br><span class="line">       //TODO:你想做的事情</span><br><span class="line">    }</span><br><span class="line">    NSLog(@"%@: %ld, %@", self, viewCount, self.navigationController);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>@property(nullable, nonatomic,readonly,strong) UINavigationController *navigationController;//这个属性<br>If the view controller or one of its ancestors is a child of a navigation controller, this property contains the owning navigation controller. This property is nil if the view controller is not embedded inside a navigation controller.<br>如果视图控制器或其祖先之一是导航控制器的子级，则此属性包含所属导航控制器。如果视图控制器未嵌入导航控制器内，则此属性为 nil。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/11/23/ios%E4%B9%8B%E4%BD%BF%E7%94%A8RTSP%E6%B5%81%E5%81%9A%E7%9B%91%E6%8E%A7%E6%88%96%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/23/ios%E4%B9%8B%E4%BD%BF%E7%94%A8RTSP%E6%B5%81%E5%81%9A%E7%9B%91%E6%8E%A7%E6%88%96%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%91/" class="post-title-link" itemprop="url">ios之使用RTSP流做监控或直播视频</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-11-23 13:44:35 / 修改时间：13:53:06" itemprop="dateCreated datePublished" datetime="2022-11-23T13:44:35+08:00">2022-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="先放demo-地址"><a href="#先放demo-地址" class="headerlink" title="先放demo 地址"></a>先放demo 地址</h1><p>  <a target="_blank" rel="noopener" href="https://github.com/ssj1314/iOS-VLC-RTSP-">https://github.com/ssj1314/iOS-VLC-RTSP-</a><br>  github 库太大，我传不上去。在网盘下载framework之后添加就行了。哪位大神教我一下。</p>
<h3 id="百度网盘也能先凑活一下了。新的链接里面有framework库-https-pan-baidu-com-s-1bQJshOx1JRpjadxS-BO6ag-提取码-vs8e"><a href="#百度网盘也能先凑活一下了。新的链接里面有framework库-https-pan-baidu-com-s-1bQJshOx1JRpjadxS-BO6ag-提取码-vs8e" class="headerlink" title="百度网盘也能先凑活一下了。新的链接里面有framework库: https://pan.baidu.com/s/1bQJshOx1JRpjadxS-BO6ag 提取码: vs8e"></a>百度网盘也能先凑活一下了。新的链接里面有framework库: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1bQJshOx1JRpjadxS-BO6ag">https://pan.baidu.com/s/1bQJshOx1JRpjadxS-BO6ag</a> 提取码: vs8e</h3><p>基友demo2 抽出来的小项目 把库抽出来了不然太大，可以把库直接放进去使用。<br>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1hrETkAo">https://pan.baidu.com/s/1hrETkAo</a> 密码: 5u6k</p>
<h3 id="1-VLC-介绍"><a href="#1-VLC-介绍" class="headerlink" title="1.VLC 介绍"></a>1.VLC 介绍</h3><p><a target="_blank" rel="noopener" href="http://www.videolan.org/vlc/">VLC</a> 是什么？(借的，这个比较全)</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://code.videolan.org/videolan/VLCKit.git">VLC</a>&nbsp;VLC媒体播放器（VideoLAN的）为Windows，Linux和OS X，Android版，iOS版的Windows Phone等平台提供一个视频播放器，解码器，它可以播放来自网络，摄像头，磁盘，光驱的文件，支持包括MPEG 1 / 2/4，H264，VC-1，DivX的，WMV，Vorbis格式，AC3，AAC等格式的解码。在windows和linux上的VLC是使用C ++ / Qt的写成，提供了一致的用户体验。同时VLC还专门为OS X提供了原生版本，Mac OS X版的VLC的用户界面使用可可框架编写，在OS X下拥有卓越的原生体验。</p>
</blockquote>
<ul>
<li>VLC还有一个非常好的功能 - 播放那些没有下载完整的视频文件。</li>
<li>VLC几乎覆盖所有媒体格式。</li>
</ul>
<p>PS:   以前也没做过，最近公司要做一个关于火车摄像头的App，没办法，找轮子吧，先找了ijkplayer，听说还是比较好使的，但由于在实现过程中经历了很多曲折，编译老失败，无奈之下，在一篇文章评论区看到这个VLC，然后就开始了研究，找了几篇文章之后，竟然成功了。哈哈 感觉好开心，大概折腾了两天，中间头疼过好多次，不过最终还是成功了，记录一下，聊作慰藉，也给后来用的人一个前车之鉴，<br>希望能有用。come on baby ！！！</p>
<h4 id="2-怎么下载使用"><a href="#2-怎么下载使用" class="headerlink" title="2.怎么下载使用"></a>2.怎么下载使用</h4><p>这是一款强大的全平台播放器, 几乎支持所有的音频、视频格式文件播放, 官网地址:<a target="_blank" rel="noopener" href="http://www.videolan.org/">http://www.videolan.org/</a></p>
<ul>
<li>在iOS 中也可以集成 VLC 的 SDK 进行开发, 使用之前需要先去官网下载 SDK, 然后编译成 iOS 中使用的库文件才能使用, 这种集成方法在编译的过程中需要 VPN 翻墙进行联网编译, 如果网速不好或者不稳定, 很容易编译出错, 如果网速好, 可以按照 wiki 的说明去编译: [<a target="_blank" rel="noopener" href="https://wiki.videolan.org/iOSCompile]">https://wiki.videolan.org/iOSCompile]</a></li>
<li>第二种方式，不用编译，直接下载这个玩意。拖到项目里就可以了。记得选copy第一个选项打钩。然后添加依赖库就可以啦。<br><img src="http://upload-images.jianshu.io/upload_images/1761100-ceb93b8e704cd91a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1D14D4AD-3085-4603-91E5-EF59A17A1D97.png"></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1761100-3ca1153dfb85b558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="D84FA38B-F24B-4614-B298-B4F9965810CF.png"></p>
<ul>
<li>so，这道题太难了，我不想编译了。百度云下载了行不- 链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1sk9QvxV">https://pan.baidu.com/s/1sk9QvxV</a> 密码: trf4</li>
</ul>
<blockquote>
<p>我被ijkplayer编译弄怕了，不敢再编译，再加上当时比较急，就选了第二种方式，简单粗暴。也可以cocoapods集成或者是直接在网上下载下来–&gt;下载地址:<a target="_blank" rel="noopener" href="http://nightlies.videolan.org/build/ios/">http://nightlies.videolan.org/build/ios/</a>.打开页面之后, 拉到网页最下面可以看到最新的MobileVLCKit.framework,如果最新的报错，可以尝试其他的。我用的是2.2.2版本，pod search 可以搜到。</p>
</blockquote>
<h5 id="3-如何集成"><a href="#3-如何集成" class="headerlink" title="3.如何集成"></a>3.如何集成</h5><p>关于如何集成，推荐大家去看这篇文章 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/178627b085c3">VLC集成与使用</a>，大神讲的已经很明白了。<br>在项目中添加依赖库(有一点不一样，大神用的比较少，我也不知道用的会不会错，我的是这样)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1761100-6fe5c89244b68e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A5D3E673-8451-4C98-9E9F-60B8978B5FE8.png"></p>
<p>我想说的只是自己遇到的一些问题，可能运气不好只有我遇到，但是还是希望写下来。<br>集成之后，第一次编译，报了个错误，说是bitcode 错误，然后把bitcode改为NO，还有VLC这个库用到了C++，所以把appdelegate.m 改为 .mm 文件。还有c++ standard library 改为第一个选项，都在build Settings里面。关于这个，请参考这篇文章，<a target="_blank" rel="noopener" href="http://blog.csdn.net/crash_zo/article/details/51459604">基于iOS 的 VLC简单 Demo</a>，这位博主写了两篇关于VLC的文章，图文并茂，写的还是不错的。</p>
<h5 id="4-具体用法"><a href="#4-具体用法" class="headerlink" title="4.具体用法"></a>4.具体用法</h5><p>因为我们这个项目对摄像头要求比较低，所以写的比较的简单，只要在用到的界面，导入头文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import&lt;MobileVLCKit/MobileVLCKit.h&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>再声明上一个属性：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong)VLCMediaPlayer *player;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>然后就可以简单使用了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad {  </span><br><span class="line">  UIView *videoView = [[UIView alloc] initWithFrame:CGRectMake(0, 50, self.view.bounds.size.width, 400)];</span><br><span class="line">&nbsp; &nbsp; videoView.backgroundColor = [UIColor blackColor];//我自己给他一个背景色，好认</span><br><span class="line">&nbsp; &nbsp; [self.view addSubview:videoView];</span><br><span class="line">&nbsp; &nbsp; VLCMediaPlayer *player = [[VLCMediaPlayer alloc] initWithOptions:nil];</span><br><span class="line">&nbsp; &nbsp; self.player = player;</span><br><span class="line">   // 播放时候的载体</span><br><span class="line">&nbsp; &nbsp; self.player.drawable = videoView;</span><br><span class="line">    //我们的RTSP 测试地址（估计你们也用不了）</span><br><span class="line">&nbsp; &nbsp; NSURL *url = [NSURL URLWithString:@"rtsp://10.0.0.89/session0.mpg"];</span><br><span class="line">    // 对象给他</span><br><span class="line">&nbsp; &nbsp; self.player.media = [VLCMedia mediaWithURL:url];</span><br><span class="line">&nbsp; &nbsp; //开始播放</span><br><span class="line">    [self.player play];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="不想看字就看图"><a href="#不想看字就看图" class="headerlink" title="不想看字就看图"></a>不想看字就看图</h4><p><img src="http://upload-images.jianshu.io/upload_images/1761100-a4582d074b315b3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A275803E-4879-4199-8D1A-830C960618C7.png"></p>
<h5 id="但这是初级使用，之前那篇博主写的很详细，需要复杂使用的同学可以去找他，地址—-gt-VLC集成与使用"><a href="#但这是初级使用，之前那篇博主写的很详细，需要复杂使用的同学可以去找他，地址—-gt-VLC集成与使用" class="headerlink" title="但这是初级使用，之前那篇博主写的很详细，需要复杂使用的同学可以去找他，地址—-> VLC集成与使用"></a>但这是初级使用，之前那篇博主写的很详细，需要复杂使用的同学可以去找他，地址—-&gt; <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/178627b085c3">VLC集成与使用</a></h5><p>,还有这个遇到问题可以看一下参考这篇文章，<a target="_blank" rel="noopener" href="http://blog.csdn.net/crash_zo/article/details/51459604">基于iOS 的 VLC简单 Demo</a>。</p>
<p>OK ！ 写完了，下次就好说了，一回生，二回熟。😝 喜欢这张图<br><img src="http://upload-images.jianshu.io/upload_images/1761100-25e2c10313385653.gif?imageMogr2/auto-orient/strip" alt="智障.gif"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/11/17/ios%E9%87%8C%E7%9A%84copy%E5%92%8CmutableCopy%E8%AE%B0%E5%BD%95%E6%8B%BE%E9%81%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/17/ios%E9%87%8C%E7%9A%84copy%E5%92%8CmutableCopy%E8%AE%B0%E5%BD%95%E6%8B%BE%E9%81%97/" class="post-title-link" itemprop="url">ios里的copy和mutableCopy记录拾遗ss</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-17 16:32:25" itemprop="dateCreated datePublished" datetime="2022-11-17T16:32:25+08:00">2022-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-29 14:48:45" itemprop="dateModified" datetime="2022-11-29T14:48:45+08:00">2022-11-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="1-深浅拷贝"><a href="#1-深浅拷贝" class="headerlink" title="1.深浅拷贝"></a>1.深浅拷贝</h4><h4 id="2-copy和mutableCopy介绍和用法"><a href="#2-copy和mutableCopy介绍和用法" class="headerlink" title="2.copy和mutableCopy介绍和用法"></a>2.copy和mutableCopy介绍和用法</h4><h4 id="3-为什么修饰block用copy"><a href="#3-为什么修饰block用copy" class="headerlink" title="3.为什么修饰block用copy"></a>3.为什么修饰block用copy</h4><h4 id="4-声明Nsarray和NSMutableArray变量时-哪个更适用copy修饰"><a href="#4-声明Nsarray和NSMutableArray变量时-哪个更适用copy修饰" class="headerlink" title="4.声明Nsarray和NSMutableArray变量时,哪个更适用copy修饰."></a>4.声明Nsarray和NSMutableArray变量时,哪个更适用copy修饰.</h4><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><h3 id="一、深浅拷贝"><a href="#一、深浅拷贝" class="headerlink" title="一、深浅拷贝"></a>一、深浅拷贝</h3><ul>
<li>1.什么是深拷贝,什么是浅拷贝<blockquote>
<p><strong>深拷贝</strong>:<br>拷贝出来的对象与源对象地址不一样! 这意味着我们修改拷贝对象对源对象没有任何影响.<br><strong>浅拷贝</strong>:<br>拷贝的是指针地址,拷贝的对象与源对象地址一致! 此时我们修改拷贝对象就是修改源对象.</p>
</blockquote>
</li>
<li>2.有些错误的观点:</li>
</ul>
<h6 id="copy就是浅拷贝-mutableCopy就是深拷贝-事实上-copy"><a href="#copy就是浅拷贝-mutableCopy就是深拷贝-事实上-copy" class="headerlink" title="copy就是浅拷贝,mutableCopy就是深拷贝. 事实上,copy"></a>copy就是浅拷贝,mutableCopy就是深拷贝. 事实上,copy</h6><ul>
<li>3.针对NSArray、NSDictonary、NSSet等容器类的对象,拷贝可以分为:<strong>“不完全深拷贝”</strong>和<strong>“完全深拷贝”</strong>.<br><strong>不完全深拷贝</strong>:拷贝出来的容器是新的对象,但是容器里面的对象还是原来的对象<br><strong>完全深拷贝</strong>:拷贝出来的容器是新的容器,里面的对象也是新的对象.</li>
</ul>
<h3 id="二、copy和mutableCopy的介绍和用法"><a href="#二、copy和mutableCopy的介绍和用法" class="headerlink" title="二、copy和mutableCopy的介绍和用法"></a>二、copy和mutableCopy的介绍和用法</h3><ul>
<li>1、看看官方文档的说明<blockquote>
<p><strong>copy (是NSCopying协议的方法)</strong><br><strong>‘’Return the object returned by copyWithZone:’’</strong><br>翻译:返回的对象是通过调用copyWithZone:这个方法返回的.</p>
</blockquote>
</li>
</ul>
<p>看了对copy的解释,就可以知道调用<strong>copy</strong>实际上是调用**copyWithZone:**这个方法,也可以说copy是copyWithZone的简写,为了方便调用.为了知道copy,我们需要知道copyWithZone的用法,<br>这个方法的官档如下:</p>
<blockquote>
<h4 id="copyWithZone"><a href="#copyWithZone" class="headerlink" title="copyWithZone:"></a>copyWithZone:</h4><p>“Returns a new instance that’s a copy of the receiver.”<br>翻译：返回一个新的实例，这个实例是接收器的副本。</p>
<p>再看看官方文档对这个方法的讨论<br><strong>“The returned object is implicitly retained by the sender, who is responsible for releasing it. The copy returned is immutable if the consideration “immutable vs. mutable” applies to the receiving object; otherwise the exact nature of the copy is determined by the class.”</strong></p>
<p>大意: 发送者隐式的保留这个的对象,同时也负责这个返回对象的释放工作.**无论接收器的对象是“可变的”或者“不可变的”,使用这个方法,返回的对象都是不可变的.**否则,拷贝对象的确切特性将由被拷贝的对象的类决定.</p>
</blockquote>
<p>在通俗的解释下,一般情况下,使用copy拷贝的对象都是不可变的,无论是拷贝可变对象还是不可变对象.最后一句说的是copy的具体特性由被拷贝的对象决定,就是说有可能copy的对象是可变.👇下面会有例子.</p>
<ul>
<li>2.再看看mutableCopy的说明<blockquote>
<h4 id="mutableCopy-是NSMutableCopy协议的方法"><a href="#mutableCopy-是NSMutableCopy协议的方法" class="headerlink" title="mutableCopy(是NSMutableCopy协议的方法)"></a>mutableCopy(是NSMutableCopy协议的方法)</h4><p><strong>“A protocol that mutable objects adopt to provide functional copies of themselves”</strong><br>可变对象采用的协议,用于提供自身的功能副本.</p>
</blockquote>
</li>
</ul>
<p>mutableCopy和copy很相似.mutableCopy是mutableCopyWithZone的简写形式,我们再来看看官方文档是怎样描述mutableCopyWithZone的.</p>
<blockquote>
<h4 id="mutableCopyWithZone"><a href="#mutableCopyWithZone" class="headerlink" title="mutableCopyWithZone:"></a>mutableCopyWithZone:</h4><p>Returns a new instance that’s a mutable copy of the receiver.<br>返回一个新的实例,这是一个可变的接收器的副本.<br>再看看官方文档对这个方法的解释<br><strong>The returned object is implicitly retained by the sender,which is responsible for releasing it.The copy returned is mutabled whether the original is mutable or not.</strong><br>大意:返回的对象由发送方隐式保留，发送方负责释放它。无论原始副本是否可变，返回的副本都是可变的</p>
</blockquote>
<p>只有定义“可变与不可变”区别的类才能应用此协议(NSMutableCopying)协议,也即只有定义可变与不可变的类,才可以使用mutablecopy.</p>
<h4 id="举例说明用法"><a href="#举例说明用法" class="headerlink" title="举例说明用法:"></a>举例说明用法:</h4><ul>
<li>1.NSString,NSMutableString的copy和mutableCopy<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    NSString * imtableString = @"这是一个不可变字符串";</span><br><span class="line">    id immutableSting_copy = [imtableString copy];</span><br><span class="line">    id immutableSting_mutablecopy = [imtableString mutableCopy];</span><br><span class="line">//    immutableSting_copy = @"这是一个不可变字符串吗?";</span><br><span class="line">//    immutableSting_mutablecopy = @"是的 这是一个不可变字符串";</span><br><span class="line">    //可变字符</span><br><span class="line">    NSMutableString * mutableStr = [[NSMutableString alloc] initWithString:@"这是一个可变字符串"];</span><br><span class="line">    id mutable_copy = [mutableStr copy];</span><br><span class="line">    id mutable_mutableCopy = [mutableStr mutableCopy];</span><br><span class="line">//    mutable_copy = @"这是一个可变字符串吗?";</span><br><span class="line">//    mutable_mutableCopy = @"是的 这是一个可变字符串";</span><br><span class="line"></span><br><span class="line">    NSLog(@"imtableString = %@",imtableString);</span><br><span class="line">    NSLog(@"immutableSting_copy = %@",immutableSting_copy);</span><br><span class="line">    NSLog(@"immutableSting_mutablecopy = %@",immutableSting_mutablecopy);</span><br><span class="line">    NSLog(@"mutableStr = %@",mutableStr);</span><br><span class="line">    NSLog(@"mutable_copy = %@",mutable_copy);</span><br><span class="line">    NSLog(@"mutable_mutableCopy = %@",mutable_mutableCopy);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不可变字符串打印</span><br><span class="line">(lldb) p imtableString</span><br><span class="line">(__NSCFConstantString *) $0 = 0x00000001026b0438 @"这是一个不可变字符串"</span><br><span class="line">(lldb) p immutableSting_copy</span><br><span class="line">(__NSCFConstantString *) $1 = 0x00000001026b0438 @"这是一个不可变字符串"</span><br><span class="line">(lldb) p immutableSting_mutablecopy</span><br><span class="line">(__NSCFString *) $2 = 0x0000000281cd4510 @"这是一个不可变字符串"</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可变字符串打印</span><br><span class="line">(lldb) p mutableStr</span><br><span class="line">(__NSCFString *) $3 = 0x0000000281cd4750 @"这是一个可变字符串"</span><br><span class="line">(lldb) p mutable_copy</span><br><span class="line">(__NSCFString *) $4 = 0x0000000281cd44b0 @"这是一个可变字符串"</span><br><span class="line">(lldb) p mutable_mutableCopy</span><br><span class="line">(__NSCFString *) $5 = 0x0000000281cd45a0 @"这是一个可变字符串"</span><br></pre></td></tr></tbody></table></figure>
<p>从控制台来看,可以看出对于可变和不可变字符串copy和mutablecopy的规律<br><strong>NSString 类型的字符串:string</strong><br>[string copy]————————–&gt;NSString类型(浅拷贝)<br>[string mutableCopy]——————&gt;NSMutableString类型(深拷贝)<br><strong>NSMutableString类型的字符串:mString</strong><br>[mString copy]————————&gt;NSMutableString类型(深拷贝)<br>[mString mutableCopy]—————-&gt;NSMutableString类型(深拷贝)</p>
<ul>
<li>2.容器类型以数组举例:NSArray和NSMutableArray的copy和mutableCopy,来看看<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSDate * a1 = [NSDate date];</span><br><span class="line">NSDate * a2 = [NSDate date];</span><br><span class="line">//不可变数组</span><br><span class="line">NSArray * arr = [NSArray arrayWithObjects:a1,a2, nil];</span><br><span class="line">id arr_copy = [arr copy];</span><br><span class="line">id arr_mutableCopy = [arr mutableCopy];</span><br><span class="line">NSLog(@"arr=%p 、arr_copy=%p",arr,arr_copy);</span><br><span class="line">NSLog(@"arr[0]=%p、 arr_copy[0]=%p",arr[0],arr_copy[0]);</span><br><span class="line">NSMutableArray * mArr = [NSMutableArray arrayWithObjects:a1,a2, nil];</span><br><span class="line">id mArr_copy = [mArr copy];</span><br><span class="line">id mArr_mutableCopy = [mArr mutableCopy];</span><br><span class="line">NSLog(@"mArr=%p 、mArr_copy=%p",mArr,mArr_copy);</span><br><span class="line">NSLog(@"mArr[0]=%p、 mArr_copy[0]=%p",mArr[0],mArr_copy[0]);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">可以看到,可变数组copy之后产生了一个新容器数组</span><br><span class="line">arr=0x280a0c240 、arr_copy=0x280a0c240</span><br><span class="line">arr[0]=0x83e97789a796f0a1、 arr_copy[0]=0x83e97789a796f0a1</span><br><span class="line">mArr=0x280444060 、mArr_copy=0x280a0c020</span><br><span class="line">mArr[0]=0x83e97789a796f0a1、 mArr_copy[0]=0x83e97789a796f0a1</span><br><span class="line">(lldb) p arr</span><br><span class="line">(__NSArrayI *) $0 = 0x0000000280a0c240 @"2 elements"</span><br><span class="line">(lldb) po arr</span><br><span class="line">&lt;__NSArrayI 0x280a0c240&gt;(</span><br><span class="line">2022-11-29 06:19:28 +0000,</span><br><span class="line">2022-11-29 06:19:28 +0000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(lldb) po arr_copy</span><br><span class="line">&lt;__NSArrayI 0x280a0c240&gt;(</span><br><span class="line">2022-11-29 06:19:28 +0000,</span><br><span class="line">2022-11-29 06:19:28 +0000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(lldb) po arr_mutableCopy</span><br><span class="line">&lt;__NSArrayM 0x2804440c0&gt;(</span><br><span class="line">2022-11-29 06:19:28 +0000,</span><br><span class="line">2022-11-29 06:19:28 +0000</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">可变数组都产生了新容器,但是里面的内容没有拷贝,</span><br><span class="line">特别注意NSMutableArray的copy之后产生的新容器是__NSArrayI,也就是不可变数组容器,所以可变数组修饰词最好用strong.</span><br><span class="line">(lldb) po mArr</span><br><span class="line">&lt;__NSArrayM 0x280444060&gt;(</span><br><span class="line">2022-11-29 06:19:28 +0000,</span><br><span class="line">2022-11-29 06:19:28 +0000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(lldb) po mArr_copy</span><br><span class="line">&lt;__NSArrayI 0x280a0c020&gt;(</span><br><span class="line">2022-11-29 06:19:28 +0000,</span><br><span class="line">2022-11-29 06:19:28 +0000</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(lldb) po mArr_mutableCopy</span><br><span class="line">&lt;__NSArrayM 0x280444000&gt;(</span><br><span class="line">2022-11-29 06:19:28 +0000,</span><br><span class="line">2022-11-29 06:19:28 +0000</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>从控制台来看,可以看出对于可变和不可变字数组copy和mutablecopy的规律</p>
<h4 id="NSArray类型的数组-arr"><a href="#NSArray类型的数组-arr" class="headerlink" title="NSArray类型的数组:arr"></a>NSArray类型的数组:arr</h4><p>[arr copy]—————————-&gt;NSArray(浅拷贝NSArrayI)<br>[arr mutableCopy]——————–&gt;NSmutableArray(深拷贝NSArrayM)</p>
<h4 id="NSMutableArray类型的数组-mArr"><a href="#NSMutableArray类型的数组-mArr" class="headerlink" title="NSMutableArray类型的数组:mArr"></a>NSMutableArray类型的数组:mArr</h4><p>[mArr copy]————————–&gt;NSArray(深拷贝为新的NSArrayI)<br>[mArr mutableCopy]————————–&gt;NSMutableArray(深拷贝NSArrayM)</p>
<h3 id="无论深浅拷贝，集合对象内元素都是浅拷贝"><a href="#无论深浅拷贝，集合对象内元素都是浅拷贝" class="headerlink" title="无论深浅拷贝，集合对象内元素都是浅拷贝"></a>无论深浅拷贝，集合对象内元素都是浅拷贝</h3><p>对于容器类型的深拷贝可分为:<strong>完全深拷贝和不完全深拷贝</strong><br>**这里大家要注意,不同对象调用copy得到的结果不一样.**正如官方文档所说:<strong>否则,拷贝对象的确切特性由被拷贝的对象的类决定.</strong></p>
<h3 id="总之-copy一般情况下是浅拷贝-但是在一些情况下-copy又是深拷贝"><a href="#总之-copy一般情况下是浅拷贝-但是在一些情况下-copy又是深拷贝" class="headerlink" title="总之,copy一般情况下是浅拷贝,但是在一些情况下,copy又是深拷贝."></a>总之,copy一般情况下是浅拷贝,但是在一些情况下,copy又是深拷贝.</h3><p>下面举个例子证明一下:<br>重写了copyWithZone方法的自定义对象,copy是(单层)深拷贝.<br>这次数组里面的元素是自定义类型的类对象</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//  Created by 华闻期货 on 2022/11/23.</span><br><span class="line">//.h文件</span><br><span class="line">@interface User : NSObject</span><br><span class="line">@property(nonatomic,copy)NSString * name;</span><br><span class="line">@property(nonatomic,copy)NSString * professional;</span><br><span class="line">@property(nonatomic,assign)NSInteger age;</span><br><span class="line">@property(nonatomic,copy)NSString * hobbies;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import "User.h"</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@interface User ()&lt;NSCopying,NSMutableCopying,NSCoding&gt;</span><br><span class="line">@end</span><br><span class="line">@implementation User</span><br><span class="line">/*————————————重写copy——————————*/</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone {</span><br><span class="line">    User *test = [[User allocWithZone:zone]init];</span><br><span class="line">    test.name = [self.name copy];</span><br><span class="line">    test.professional = [self.professional copy];</span><br><span class="line">    test.age = self.age;</span><br><span class="line">    test.hobbies = [self.hobbies copy];</span><br><span class="line">        return test;</span><br><span class="line">}</span><br><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone {</span><br><span class="line">    User *test = [User allocWithZone:zone];</span><br><span class="line">    test.name = [self.name mutableCopy];</span><br><span class="line">    test.professional = [self.professional mutableCopy];</span><br><span class="line">    test.age = self.age;</span><br><span class="line">    test.hobbies = [self.hobbies mutableCopy];</span><br><span class="line">    return test;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试代码:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    User * a1 = [[User alloc] init];</span><br><span class="line">    a1.name = @"小明";</span><br><span class="line">    a1.professional = @"奥特曼";</span><br><span class="line">    a1.age = 32;</span><br><span class="line">    a1.hobbies = @"看书";</span><br><span class="line">//    两种写法不一样 array1是NSArray的话,[array1 copy] 是浅拷贝</span><br><span class="line">//    array1是NSMutableArray的话,[array1 copy] 是深拷贝</span><br><span class="line">//    NSArray *array1 = [NSArray arrayWithObjects:a1, nil];</span><br><span class="line">    NSMutableArray *array1 = [NSMutableArray arrayWithObjects:a1, nil];</span><br><span class="line">    </span><br><span class="line">    NSArray *array2 = [array1 copy];</span><br><span class="line">    NSMutableArray *array3 = [array1 mutableCopy];</span><br><span class="line">    NSMutableArray *array4 = [[NSMutableArray alloc] initWithArray:array1 copyItems:true];</span><br><span class="line">    NSMutableArray *array5 = [[NSMutableArray alloc] initWithObjects:[array1[0] copy], nil];</span><br><span class="line">    NSMutableArray *array6 = [[NSMutableArray alloc] initWithObjects:[array1[0] mutableCopy], nil];</span><br><span class="line">    </span><br><span class="line">    NSLog(@"\n array1 = %p class = %@", array1, [array1 class]);</span><br><span class="line">    NSLog(@"\n array2 = %p class = %@", array2, [array2 class]);</span><br><span class="line">    NSLog(@"\n array3 = %p class = %@", array3, [array3 class]);</span><br><span class="line">    NSLog(@"\n array4 = %p class = %@", array4, [array4 class]);</span><br><span class="line">    NSLog(@"\n array5 = %p class = %@", array5, [array5 class]);</span><br><span class="line">    NSLog(@"\n array6 = %p class = %@", array6, [array6 class]);</span><br><span class="line">    </span><br><span class="line">    NSLog(@"\n\n======== 数组内元素 ========");</span><br><span class="line">    User *orgArrayObj = (User *)array1[0];</span><br><span class="line">    User *newArrayObj2 = (User *)array2[0];</span><br><span class="line">    User *newArrayObj3 = (User *)array3[0];</span><br><span class="line">    User *newArrayObj4 = (User *)array4[0];</span><br><span class="line">    User *newArrayObj5 = (User *)array5[0];</span><br><span class="line">    User *newArrayObj6 = (User *)array6[0];</span><br><span class="line">    NSLog(@"\n array1[0] = %p nickname = %p", orgArrayObj, orgArrayObj.name);</span><br><span class="line">    NSLog(@"\n array2[0] = %p nickname = %p", newArrayObj2, newArrayObj2.name);</span><br><span class="line">    NSLog(@"\n array3[0] = %p nickname = %p", newArrayObj3, newArrayObj3.name);</span><br><span class="line">    NSLog(@"\n array4[0] = %p nickname = %p", newArrayObj4, newArrayObj4.name);</span><br><span class="line">    NSLog(@"\n array5[0] = %p nickname = %p", newArrayObj5, newArrayObj5.name);</span><br><span class="line">    NSLog(@"\n array6[0] = %p nickname = %p", newArrayObj6, newArrayObj6.name);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">容器全部为深拷贝</span><br><span class="line"> array1 = 0x28041c0f0 class = __NSArrayM</span><br><span class="line"></span><br><span class="line"> array2 = 0x280868020 class = __NSSingleObjectArrayI</span><br><span class="line"></span><br><span class="line"> array3 = 0x28041c120 class = __NSArrayM</span><br><span class="line"></span><br><span class="line"> array4 = 0x280428510 class = __NSArrayM</span><br><span class="line"></span><br><span class="line"> array5 = 0x2804283c0 class = __NSArrayM</span><br><span class="line"></span><br><span class="line"> array6 = 0x280428330 class = __NSArrayM</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">======== 数组内元素 ========</span><br><span class="line">内容为浅拷贝</span><br><span class="line"> array1[0] = 0x28041c030 name = 0x10431c478</span><br><span class="line"></span><br><span class="line"> array2[0] = 0x28041c030 name = 0x10431c478</span><br><span class="line"></span><br><span class="line"> array3[0] = 0x28041c030 name = 0x10431c478</span><br><span class="line"></span><br><span class="line"> array4[0] = 0x2804280c0 name = 0x10431c478</span><br><span class="line"></span><br><span class="line"> array5[0] = 0x280428090 name = 0x10431c478</span><br><span class="line"></span><br><span class="line"> array5[0] = 0x280428090 hobby = 0x10431c4b8</span><br><span class="line">内容为深拷贝</span><br><span class="line"> array6[0] = 0x280428270 name = 0x280a540a0</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1761100-b1394fe82be744d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="打印"><br>对于重写了copyWithZone、mutableWithZone的自定义对象装在NSMutableArray里</p>
<ul>
<li>[array copy]、[array mutableCopy]只是深拷贝了容器array对象,元素是浅拷贝;</li>
<li>[initWithArray:array1 copyItems:]生成了新的array, 且array内元素User是深拷贝,但是User的属性仍然是浅拷贝(注意:此处属性浅拷贝是因为:name是NSString对象,copyItems调用的是copyWithZone,[NSSring copy]是浅拷贝)</li>
<li>通过遍历array,对User分别拷贝,会调用User的copyWithZone,此时NSArray是深拷贝,NSArray内元素user是深拷贝,user的属性参数是否是深拷贝,取决于属性的类型(NSString浅拷贝,NSMutableString深拷贝)<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array1[0] = 0x2810415f0 name = 0x1047f4438</span><br><span class="line"></span><br><span class="line"> array2[0] = 0x2810415f0 name = 0x1047f4438</span><br><span class="line"></span><br><span class="line"> array3[0] = 0x2810415f0 name = 0x1047f4438</span><br><span class="line"></span><br><span class="line"> array4[0] = 0x281041770 name = 0x1047f4438</span><br><span class="line"></span><br><span class="line"> array5[0] = 0x2810418f0 name = 0x1047f4438</span><br><span class="line">hobby是@property(nonatomic,copy)NSMutableString * hobbies;</span><br><span class="line"> array5[0] = 0x2810418f0 hobby = 0x1047f4478</span><br></pre></td></tr></tbody></table></figure></li>
<li>通过遍历array,对user分别mutableCopy,会调用user的mutableCopyWithZone,此时NSarray是深拷贝,NSArray内元素是深拷贝,元素的属性参数也是深拷贝.</li>
</ul>
<h5 id="此时我们可知-要对自定义对象深拷贝-解决方案是重写copyWithZone、mutableCopyWithZone-调用对应方法-还有一种方式-归档"><a href="#此时我们可知-要对自定义对象深拷贝-解决方案是重写copyWithZone、mutableCopyWithZone-调用对应方法-还有一种方式-归档" class="headerlink" title="此时我们可知,要对自定义对象深拷贝,解决方案是重写copyWithZone、mutableCopyWithZone,调用对应方法.还有一种方式:归档"></a>此时我们可知,要对自定义对象深拷贝,解决方案是重写copyWithZone、mutableCopyWithZone,调用对应方法.还有一种方式:归档</h5><ul>
<li>3 用归档的方式深拷贝自定义对象<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#import "User.h"</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@interface User ()&lt;NSCopying,NSMutableCopying,NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation User</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder {</span><br><span class="line">    unsigned int count;</span><br><span class="line">    Ivar *ivar = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    for (int i = 0 ; i &lt; count ; i++) {</span><br><span class="line">        Ivar iv = ivar[i];</span><br><span class="line">        const char *name = ivar_getName(iv);</span><br><span class="line">        NSString *strName = [NSString stringWithUTF8String:name];</span><br><span class="line">        //利用KVC取值</span><br><span class="line">        id value = [self valueForKey:strName];</span><br><span class="line">        [aCoder encodeObject:value forKey:strName];</span><br><span class="line">    }</span><br><span class="line">    free(ivar);</span><br><span class="line">}</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder {</span><br><span class="line">    User *test = [[User alloc]init];</span><br><span class="line">    if (self != nil) {</span><br><span class="line">        unsigned int count = 0;</span><br><span class="line">        Ivar *ivar = class_copyIvarList([self class], &amp;count);</span><br><span class="line">        for (int i= 0 ;i &lt; count ; i++) {</span><br><span class="line">            Ivar var = ivar[i];</span><br><span class="line">            const char *keyName = ivar_getName(var);</span><br><span class="line">            NSString *key = [NSString stringWithUTF8String:keyName];</span><br><span class="line">            id value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [test setValue:value forKey:key];</span><br><span class="line">        }</span><br><span class="line">        free(ivar);</span><br><span class="line">    }</span><br><span class="line">    return test;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (void)dealloc {</span><br><span class="line">    NSLog(@"User-dealloc");</span><br><span class="line">}</span><br><span class="line">@end</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码:"></a>测试代码:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//归档深拷贝测试</span><br><span class="line">NSMutableArray * array1 = [NSMutableArray arrayWithObjects:a1, nil];</span><br><span class="line">NSData * data = [NSKeyedArchiver archivedDataWithRootObject:array1];</span><br><span class="line">NSMutableArray * array2 = [NSKeyedUnarchiver unarchiveObjectWithData:data];</span><br><span class="line"></span><br><span class="line">NSLog(@"\n array1 = %p,class1 = %@",array1,[array1 class]);</span><br><span class="line">NSLog(@"\n array2 = %p,class2 = %@",array2,[array2 class]);</span><br><span class="line"></span><br><span class="line">NSLog(@"\n----------数组内元素是否深拷贝------------\n");</span><br><span class="line">User * orgArrayObj = (User *)array1[0];</span><br><span class="line">User * newArrayObj2 = (User *)array2[0];</span><br><span class="line">NSLog(@"array1[0]= %p,name = %p",orgArrayObj,orgArrayObj.name);</span><br><span class="line">NSLog(@"array2[0]= %p,name = %p",newArrayObj2,newArrayObj2.name);</span><br></pre></td></tr></tbody></table></figure>
<h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果:"></a>测试结果:</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-11-28 14:01:18.504350+0800 Set[1177:47745] User-dealloc</span><br><span class="line"></span><br><span class="line"> array1 = 0x2809c9380,class1 = __NSArrayM</span><br><span class="line"></span><br><span class="line"> array2 = 0x2809c9170,class2 = __NSArrayM</span><br><span class="line"></span><br><span class="line">----------数组内元素是否深拷贝------------</span><br><span class="line"></span><br><span class="line">array1[0]= 0x2809c9320,name = 0x102748438</span><br><span class="line">array2[0]= 0x2809c9350,name = 0x2807fefa0</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#dd0000"> 很明显,不仅数组本身被深拷贝了,数组里面的自定义对象属性都被深拷贝了 </font></p>
<h3 id="时间之外的往事-声明Nsarray和NSMutableArray变量时-哪个更适用copy修饰"><a href="#时间之外的往事-声明Nsarray和NSMutableArray变量时-哪个更适用copy修饰" class="headerlink" title="时间之外的往事  声明Nsarray和NSMutableArray变量时,哪个更适用copy修饰."></a>时间之外的往事  声明Nsarray和NSMutableArray变量时,哪个更适用copy修饰.</h3><ul>
<li><p>1.如果使用strong来修饰NSArray类型的数组，当array的数组被赋值了可变数组对象时，当可变数组改变时，NSArray数组里的对象也会跟着改变，这是我们不想要的结果。使用copy修饰，在被赋值可变数组时，会生成一个新的不可变数组对象，这样可变数组之后怎样变化，都不会影响NSArray类型的数组对象。</p>
</li>
<li><p>2.使用strong来修饰NSMutableArray类型的数组，当mArray的数组被赋值了可变数组对象时，当可变数组改变时，NSMutableArray数组里的对象也会跟着改变，这是符合我们预期的。当使用copy修饰后，被赋值后，会生成一个新的不可变数组对象。这样我们还以为它是可变类型的数组，然后使用增删改查，就会crash，也谈不上可以改变数组对象了。</p>
</li>
<li><p>3.综上，用property声明NSArray数组时，最好使用copy。用property声明NSMutableArray数组时，最好使用strong。如果使用copy，又self.mArr来赋值，后面增删改查，程序肯定会crash的。</p>
</li>
</ul>
<h3 id="时间之外的往事二-为什么block使用copy？"><a href="#时间之外的往事二-为什么block使用copy？" class="headerlink" title="时间之外的往事二 为什么block使用copy？"></a>时间之外的往事二 为什么block使用copy？</h3><ul>
<li>block是一个对象, 所以block理论上是可以retain/release的. 但是block在创建的时候它的内存是默认是分配在栈(stack)上, 而不是堆(heap)上的. 所以它的作用域仅限创建时候的当前上下文(函数, 方法…), 当你在该作用域外调用该block时, 程序就会崩溃.</li>
<li>其实block使用copy是MRC时代留下来的传统。 在MRC下, 在方法中的block创建在栈区, 使用copy就能把他放到堆区, 这样在作用域外调用该block程序就不会崩溃. 但在ARC下, 使用copy与strong其实都一样, 因为block的retain就是用copy来实现的。之所以大家都习惯用copy就是MRC时代留下的习惯。</li>
</ul>
<h3 id="总结一下啊"><a href="#总结一下啊" class="headerlink" title="总结一下啊"></a>总结一下啊</h3><ul>
<li>copy: 对NSArray对象是浅拷贝,对NSMutableArray对象是深拷贝</li>
<li>mutableCopy是深拷贝.<font color="dd0000">注意这些都是单层深拷贝</font></li>
<li>要实现array内元素深拷贝,本质是元素全部进行深拷贝</li>
<li>initWithArray:array1 copyItems:生成了新的array,copyItems:true 只是调用了array的copyWithZone方法,array内元素是浅拷贝.</li>
<li>通过遍历array,对User分别拷贝,会调用User的copyWithZone,此时NSArray是深拷贝,NSArray内元素user是深拷贝,user的属性参数是否是深拷贝,取决于属性的类型(NSString浅拷贝,NSMutableString深拷贝)</li>
<li>通过遍历array,对user分别mutableCopy,会调用user的mutableCopyWithZone,此时NSarray是深拷贝,NSArray内元素是深拷贝,元素的属性参数也是深拷贝.</li>
<li>通过归解档的方式,可以实现对array、array内元素属性深拷贝.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/10/26/%E7%8A%B6%E6%80%81%E6%A0%8F%E6%8B%BE%E9%81%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/26/%E7%8A%B6%E6%80%81%E6%A0%8F%E6%8B%BE%E9%81%97/" class="post-title-link" itemprop="url">状态栏拾遗</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-26 16:34:50" itemprop="dateCreated datePublished" datetime="2022-10-26T16:34:50+08:00">2022-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-28 14:55:29" itemprop="dateModified" datetime="2022-10-28T14:55:29+08:00">2022-10-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-局部隐藏-x2F-显示状态栏"><a href="#1-局部隐藏-x2F-显示状态栏" class="headerlink" title="1.局部隐藏/显示状态栏"></a>1.局部隐藏/显示状态栏</h3><h4 id="1-1-方式1-将View-controller-based-status-bar-appearance-设置为YES-没有可以不加。"><a href="#1-1-方式1-将View-controller-based-status-bar-appearance-设置为YES-没有可以不加。" class="headerlink" title="1.1 方式1:将View controller-based status bar appearance 设置为YES,没有可以不加。"></a>1.1 方式1:将View controller-based status bar appearance 设置为YES,没有可以不加。</h4><ul>
<li>注意：该方式仅支持iOS7及以上版本（参考<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/bundleresources/information_property_list/uiviewcontrollerbasedstatusbarappearance?language=objc">UIViewControllerBasedStatusBarAppearance</a>）2022年最低也只能支持9.0了</li>
</ul>
<ul>
<li>注意：如果当前controller界面是在Nav等容器里面,prefersStatusBarHidden是不起作用的，需要在分类里面重写</li>
</ul>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> #import "UINavigationController+ssjStatusbar.h"</span><br><span class="line"></span><br><span class="line">@implementation UINavigationController (ssjStatusbar)</span><br><span class="line">-(UIViewController *)childViewControllerForStatusBarHidden</span><br><span class="line">{</span><br><span class="line">    return  self.visibleViewController;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-(UIViewController *)childViewControllerForStatusBarStyle</span><br><span class="line">{</span><br><span class="line">    return  self.visibleViewController;</span><br><span class="line">}</span><br><span class="line">@end</span><br></pre></td></tr></tbody></table></figure>



<p>1.在info.plist里将<font color="#dd0000">View controller-based status bar appearance</font>设置为YES  </p>
<h4 id="第一步可以省略"><a href="#第一步可以省略" class="headerlink" title="第一步可以省略"></a>第一步可以省略</h4><p>2.在控制器里定义一个属性：<font color="#dd0000">statusHiden</font>并重写<font color="#dd0000">prefersStatusbarHiden</font><br><code>@property(nonatomic,assign) BOOL statusHiden;</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) setStatusHiden:(BOOL)statusHiden{</span><br><span class="line">    self.statusHiden = statusHiden;</span><br><span class="line">    // 刷新状态栏</span><br><span class="line">    [self performSelector:@selector(setNeedsStatusBarAppearanceUpdate)];</span><br><span class="line">}</span><br><span class="line">- (BOOL)prefersStatusBarHidden{</span><br><span class="line">     return self.statusHiden;</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>3.改变状态栏的显示状态</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//隐藏状态栏</span><br><span class="line">self.statusHiden = YES;</span><br><span class="line"></span><br><span class="line">//显示状态栏</span><br><span class="line">self.statusHiden = NO;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h5 id="info-plist文件中，View-controller-based-status-bar-appearance项设为"><a href="#info-plist文件中，View-controller-based-status-bar-appearance项设为" class="headerlink" title="info.plist文件中，View controller-based status bar appearance项设为:"></a>info.plist文件中，View controller-based status bar appearance项设为:</h5><ul>
<li>YES:则View controller对status bar的设置优先级高于application的设置。</li>
<li>NO: 则以application的设置为准，view controller的prefersStatusBarHidden以及preferredStatusBarStyle方法无效，是根本不会被调用的。</li>
</ul>
<h4 id="1-2-方式2-将View-Controller-based-status-bar-appearance-设置为NO"><a href="#1-2-方式2-将View-Controller-based-status-bar-appearance-设置为NO" class="headerlink" title="1.2 方式2 将View Controller-based status bar appearance 设置为NO"></a>1.2 方式2 将View Controller-based status bar appearance 设置为NO</h4><p>注：该方式支持所有版本<br>注：该方式影响所有的控制器，注意使用控制器的生命周期<br>1.在info.plift将View Controller-based status bar appearance 设置为No<br>2.在控制器里面改变状态栏的隐藏和显示</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//隐藏状态栏</span><br><span class="line">[[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:UIStatusBarAnimationNone];</span><br><span class="line">//显示状态栏</span><br><span class="line">[[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationNone];</span><br></pre></td></tr></tbody></table></figure>


<h3 id="2-设置状态栏样式"><a href="#2-设置状态栏样式" class="headerlink" title="2.设置状态栏样式"></a>2.设置状态栏样式</h3><h4 id="2-1状态栏样式："><a href="#2-1状态栏样式：" class="headerlink" title="2.1状态栏样式："></a>2.1状态栏样式：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIStatusBarStyle) {</span><br><span class="line">    //默认样式，黑字透明状态栏，适合用于背景色为亮色的页面</span><br><span class="line">    UIStatusBarStyleDefault                                     = 0, // Dark content, for use on light backgrounds</span><br><span class="line">    //白字透明状态栏，适合用于背景色为暗色的页面</span><br><span class="line">    UIStatusBarStyleLightContent     NS_ENUM_AVAILABLE_IOS(7_0) = 1, // Light content, for use on dark backgrounds</span><br><span class="line">    </span><br><span class="line">    // iOS7.0以前黑底白字，iOS7以后跟UIStatusBarStyleLightContent效果一样</span><br><span class="line">    UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, "Use UIStatusBarStyleLightContent") = 1,</span><br><span class="line">    // iOS7.0以前启动页为灰底白字，iOS7以后跟UIStatusBarStyleLightContent效果一样</span><br><span class="line">    UIStatusBarStyleBlackOpaque      NS_ENUM_DEPRECATED_IOS(2_0, 7_0, "Use UIStatusBarStyleLightContent") = 2,</span><br><span class="line">} __TVOS_PROHIBITED;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-方式1：将-将View-controller-based-status-bar-appearance-设置为YES，没有可以省略"><a href="#2-2-方式1：将-将View-controller-based-status-bar-appearance-设置为YES，没有可以省略" class="headerlink" title="2.2 方式1：将  将View controller-based status bar appearance 设置为YES，没有可以省略"></a>2.2 方式1：将  将View controller-based status bar appearance 设置为YES，没有可以省略</h4><ol>
<li>2.在控制器里面定义一个属性barStyle并重写preferredStatusBarStyle<br><code>@property(nonatomic,assign) NSInteger barStyle; </code><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void) setBarStyle:(NSInteger) barStyle{</span><br><span class="line">    self.barStyle = barStyle;</span><br><span class="line">    [self performSelector:@selector(setNeedsStatusBarAppearanceUpdate)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 状态栏的样式</span><br><span class="line">- (UIStatusBarStyle)preferredStatusBarStyle{</span><br><span class="line">     return self.barStyle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
3.改变状态栏样式<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.barStyle = UIStatusBarStyleDefault;</span><br><span class="line"></span><br><span class="line">//状态栏白色样式</span><br><span class="line">self.barStyle = UIStatusBarStyleLightContent;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="2-3-将View-controller-based-status-bar-appearance-设置为NO"><a href="#2-3-将View-controller-based-status-bar-appearance-设置为NO" class="headerlink" title="2.3 将View controller-based status bar appearance 设置为NO"></a>2.3 将View controller-based status bar appearance 设置为NO</h4><p>1.在info.plist里将View controller-based status bar appearance 设置为NO<br>2.在控制器里修改状态栏样式</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//状态栏黑色样式</span><br><span class="line">[[UIApplication sharedApplication]setStatusBarStyle:UIStatusBarStyleDefault];</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//状态栏白色样式</span><br><span class="line">[[UIApplication sharedApplication]setStatusBarStyle:UIStatusBarStyleLightCont</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-UIViewController中其他有关状态栏的函数"><a href="#2-UIViewController中其他有关状态栏的函数" class="headerlink" title="2.UIViewController中其他有关状态栏的函数"></a>2.UIViewController中其他有关状态栏的函数</h3><ul>
<li>preferredStatusBarUpdateAnimation函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> - (UIStatusBarAnimation)preferredStatusBarUpdateAnimation </span><br><span class="line">NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED; // Defaults to UIStatusBarAnimationFade</span><br></pre></td></tr></tbody></table></figure>
该函数用来设置状态栏显示/消失时的动画类型，动画类型有：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIStatusBarAnimation) {</span><br><span class="line">    UIStatusBarAnimationNone,</span><br><span class="line">    UIStatusBarAnimationFade NS_ENUM_AVAILABLE_IOS(3_2),</span><br><span class="line">    UIStatusBarAnimationSlide NS_ENUM_AVAILABLE_IOS(3_2),</span><br><span class="line">} __TVOS_PROHIBITED;</span><br></pre></td></tr></tbody></table></figure>
默认为<font color="#dd0000">UIStatusBarAnimationFade</font>,状态栏发生改变的时候，该函数的返回值就会发挥作用。</li>
<li>childViewControllerForStatusBarStyle函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Override to return a child view controller or nil. If non-nil, that view controller's status bar appearance attributes will be used. If nil, self is used. Whenever the return values from these methods change, -setNeedsUpdatedStatusBarAttributes should be called.</span><br><span class="line">- (nullable UIViewController *)childViewControllerForStatusBarStyle </span><br><span class="line">NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;</span><br></pre></td></tr></tbody></table></figure>
这个函数的返回值默认返回nil，此时系统就会调用当前viewControllerA的preferredStatusBarStyle函数；如果返回值是另一个viewControllerB那么系统就会调用viewControllerB的preferredStatusBarStyle函数。</li>
</ul>
<p>运用这个函数就可以解决嵌套UINavigationController设置样式无效的问题。</p>
<blockquote>
<p>解释一下为什么嵌套UINavigationController的viewController的preferredStatusBarStyle函数设置无效：<br>在我们嵌套了UINavigationController的时候，我们的<br>AppDelegate.window.rootViewController<br>通常是我们创建的navigationController，这时首先会调用的是navigationController中的childViewControllerForStatusBarStyle函数，因为默认返回nil，那么接下来就会调用navigationController本身的preferredStatusBarStyle函数，所以我们在viewController中通过preferredStatusBarStyle函数设置的状态栏样式就不会被调用发现，所以也就无效了。</p>
</blockquote>
<h5 id="所以：需要在分类里面重写"><a href="#所以：需要在分类里面重写" class="headerlink" title="所以：需要在分类里面重写"></a>所以：需要在分类里面重写</h5> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> #import "UINavigationController+ssjStatusbar.h"</span><br><span class="line"></span><br><span class="line">@implementation UINavigationController (ssjStatusbar)</span><br><span class="line">-(UIViewController *)childViewControllerForStatusBarHidden</span><br><span class="line">{</span><br><span class="line">    return  self.visibleViewController;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-(UIViewController *)childViewControllerForStatusBarStyle</span><br><span class="line">{</span><br><span class="line">    return  self.visibleViewController;</span><br><span class="line">}</span><br><span class="line">@end</span><br></pre></td></tr></tbody></table></figure>
<p>这样navgationController中的childViewControllerForStatusBarStyle函数会返回nav中最上层的viewController,此时ViewController中的preferredStatusBarStyle函数的设置就会被系统获知。</p>
<ul>
<li>childViewControllerForStatusBarHidden函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIViewController *)childViewControllerForStatusBarHidden </span><br><span class="line"></span><br><span class="line">NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;</span><br></pre></td></tr></tbody></table></figure>
childViewControllerForStatusBarHidden函数的使用原理同上，不再赘述。</li>
<li>preferredStatusBarUpdateAnimation函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Override to return the type of animation that should be used for status bar changes for this view controller. This currently only affects changes to prefersStatusBarHidden.</span><br><span class="line">- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation </span><br><span class="line">NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED; // Defaults to UIStatusBarAnimationFade</span><br></pre></td></tr></tbody></table></figure>
动画形式如下<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIStatusBarAnimation) {</span><br><span class="line">    UIStatusBarAnimationNone,</span><br><span class="line">    UIStatusBarAnimationFade NS_ENUM_AVAILABLE_IOS(3_2),</span><br><span class="line">    UIStatusBarAnimationSlide NS_ENUM_AVAILABLE_IOS(3_2),</span><br><span class="line">} __TVOS_PROHIBITED;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
这个函数返回了动画效果。动画效果只有在prefersStatusBarHidden<br>函数返回值变化的时候才会展示，同时要通过调用<br>[self setNeedsStatusBarAppearanceUpdate]函数来重绘状态栏</li>
</ul>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><p>我们可以通过隐藏系统状态栏，然后自定义<br>创建一个UIView，<br>设置该UIView的frame.size 和statusBar大小一样，<br>设置该UIView的frame.origin 为{0,-20},<br>设置该UIView的背景色为你希望的statusBar的颜色，<br>在navigationBar上addSubView该UIView即可</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/10/18/OC%E7%AC%AC%E4%B8%80%E8%AF%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/18/OC%E7%AC%AC%E4%B8%80%E8%AF%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2/" class="post-title-link" itemprop="url">OC第一课对象的底层探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-18 10:18:44" itemprop="dateCreated datePublished" datetime="2022-10-18T10:18:44+08:00">2022-10-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/09/28/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/28/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">Xcode快捷键</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-28 10:13:12 / 修改时间：10:22:00" itemprop="dateCreated datePublished" datetime="2022-09-28T10:13:12+08:00">2022-09-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://github.com/ssj1314/hexoYun/raw/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg"></p>
<h3 id="Mac-键盘快捷键"><a href="#Mac-键盘快捷键" class="headerlink" title="Mac 键盘快捷键"></a>Mac 键盘快捷键</h3><p>您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。</p>
<p>要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常使用符号来表示某些按键，其中包括以下修饰键：</p>
<pre><code>Command（或 Cmd）⌘
Shift ⇧

Option（或 Alt）⌥
Control（或 Ctrl）⌃

Caps Lock ⇪
Fn
</code></pre>
<p>在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。</p>
<p>Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。</p>
<h3 id="剪切、拷贝、粘贴和其他常用快捷键"><a href="#剪切、拷贝、粘贴和其他常用快捷键" class="headerlink" title="剪切、拷贝、粘贴和其他常用快捷键"></a>剪切、拷贝、粘贴和其他常用快捷键</h3><pre><code>Command-X：剪切所选项并拷贝到剪贴板。
Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。
Command-V：将剪贴板的内容粘贴到当前文稿或 App 中。这同样适用于“访达”中的文件。
Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些 App 中，您可以撤销和重做多个命令。
Command-A：全选各项。
Command-F：查找文稿中的项目或打开“查找”窗口。
Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。
Command-H：隐藏最前面的 App 的窗口。要查看最前面的 App 但隐藏所有其他 App，请按 Option-Command-H。
Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的 App 的所有窗口，请按 Option-Command-M。
Command-O：打开所选项，或打开一个对话框以选择要打开的文件。
Command-P：打印当前文稿。
Command-S：存储当前文稿。
Command-T：打开新标签页。
Command-W：关闭最前面的窗口。要关闭 App 的所有窗口，请按下 Option-Command-W。
Option-Command-Esc：强制退出 App。
Command-空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。）
Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。
Control-Command-F：全屏使用 App（如果 App 支持）。
空格键：使用“快速查看”来预览所选项。
Command-Tab：在打开的 App 中切换到下一个最近使用的 App。
Shift-Command-5：在 macOS Mojave 或更高版本中，拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。进一步了解截屏。
Shift-Command-N：在“访达”中创建一个新文件夹。
Command-逗号 (,)：打开最前面的 App 的偏好设置。
</code></pre>
<h3 id="睡眠、退出登录和关机快捷键"><a href="#睡眠、退出登录和关机快捷键" class="headerlink" title="睡眠、退出登录和关机快捷键"></a>睡眠、退出登录和关机快捷键</h3><p>在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样有助于避免无意中启用快捷键。</p>
<pre><code>电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态*。继续按住则会强制 Mac 关机。
Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。
Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。
Control–电源按钮* 或 Control–介质推出键 ：显示一个对话框，询问您是要重新启动、睡眠还是关机。
Control–Command–电源按钮*：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。
Control–Command–Media Eject（Control–Command–介质推出键）：退出所有 App，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。
Control–Option–Command–电源按钮* 或 Control–Option–Command–介质推出键 ：退出所有 App，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。
Control-Command-Q：立即锁定屏幕。
Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。
</code></pre>
<ul>
<li>不适用于触控 ID 传感器。</li>
</ul>
<h3 id="访达和系统快捷键"><a href="#访达和系统快捷键" class="headerlink" title="访达和系统快捷键"></a>访达和系统快捷键</h3><pre><code>Command-D：复制所选文件。
Command-E：推出所选磁盘或宗卷。
Command-F：在“访达”窗口中开始“聚焦”搜索。
Command-I：显示所选文件的“显示简介”窗口。
Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些 App（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。
Shift-Command-C：打开“电脑”窗口。
Shift-Command-D：打开“桌面”文件夹。
Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。
Shift-Command-G：打开“前往文件夹”窗口。
Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。
Shift-Command-I：打开 iCloud 云盘。
Shift-Command-K：打开“网络”窗口。
Option-Command-L：打开“下载”文件夹。
Shift-Command-N：新建文件夹。
Shift-Command-O：打开“文稿”文件夹。
Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。
Shift-Command-R：打开“隔空投送”窗口。
Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。
Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）
Shift-Command-U：打开“实用工具”文件夹。
Option-Command-D：显示或隐藏“程序坞”。
Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。
Option-Command-P：隐藏或显示“访达”窗口中的路径栏。
Option-Command-S：隐藏或显示“访达”窗口中的边栏。
Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。
Command-J：显示“显示”选项。
Command-K：打开“连接服务器”窗口。
Control-Command-A：为所选项制作替身。
Command-N：打开一个新的“访达”窗口。
Option-Command-N：新建智能文件夹。
Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。
Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。
Option-Command-V：将剪贴板中的文件从原始位置移动到当前位置。
Command-Y：使用“快速查看”预览所选文件。
Option-Command-Y：显示所选文件的快速查看幻灯片显示。
Command-1：以图标方式显示“访达”窗口中的项目。
Command-2：以列表方式显示“访达”窗口中的项目。
Command-3：以分栏方式显示“访达”窗口中的项目。
Command-4：以画廊方式显示“访达”窗口中的项目。
Command–左中括号 ([)：前往上一文件夹。
Command–右中括号 (])：前往下一个文件夹。
Command–上箭头：打开包含当前文件夹的文件夹。
Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。
Command–下箭头：打开所选项。
右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。
左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。
Command-Delete：将所选项移到废纸篓。
Shift-Command-Delete：清倒废纸篓。
Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。
Command-调低亮度：当 Mac 连接到多台显示器时，打开或关闭视频镜像功能。
Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。
Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。
Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。
Option–“调度中心”：打开“调度中心”偏好设置。
Command–“调度中心”：显示桌面。
Control–下箭头：显示最前面的 App 的所有窗口。
Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。
Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。
Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。
Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。
连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。
连按 Command 键：在单独的标签页或窗口中打开文件夹。
按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。
按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。
拖移时按住 Option-Command：为拖移的项目制作替身。拖移项目时指针会随之变化。
按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。
按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。
了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 
点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。
</code></pre>
<h3 id="文稿快捷键"><a href="#文稿快捷键" class="headerlink" title="文稿快捷键"></a>文稿快捷键</h3><p>这些快捷键的行为可能因您使用的 App 而异。</p>
<pre><code>Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。
Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。
Command-K：添加网页链接。
Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。
Command-T：显示或隐藏“字体”窗口。
Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。
Control-Command-D：显示或隐藏所选字词的定义。
Shift-Command–冒号 (:)：显示“拼写和语法”窗口。
Command–分号 (;)：查找文稿中拼写错误的字词。
Option-Delete：删除插入点左边的字词。
Control-H：删除插入点左边的字符。也可以使用 Delete 键。
Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。
Fn-Delete：在没有向前删除   键的键盘上向前删除。也可以使用 Control-D。
Control-K：删除插入点与行或段落末尾处之间的文本。
Fn–上箭头：Page Up：向上滚动一页。
Fn–下箭头：Page Down：向下滚动一页。
Fn–左箭头：Home：滚动到文稿开头。
Fn–右箭头：End：滚动到文稿末尾。
Command–上箭头：将插入点移至文稿开头。
Command–下箭头：将插入点移至文稿末尾。
Command–左箭头：将插入点移至当前行的行首。
Command–右箭头：将插入点移至当前行的行尾。
Option–左箭头：将插入点移至上一字词的词首。
Option–右箭头：将插入点移至下一字词的词尾。
Shift-Command–上箭头：选中插入点与文稿开头之间的文本。
Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。
Shift-Command–左箭头：选中插入点与当前行行首之间的文本。
Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。
Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。
Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。
Shift–左箭头：将文本选择范围向左扩展一个字符。
Shift–右箭头：将文本选择范围向右扩展一个字符。
Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。
Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。
Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。
Option–Shift–右箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。
Control–A：移至行或段落的开头。
Control–E：移至行或段落的末尾。
Control–F：向前移动一个字符。
Control–B：向后移动一个字符。
Control–L：将光标或所选内容置于可见区域中央。
Control–P：上移一行。
Control–N：下移一行。
Control–O：在插入点后新插入一行。
Control–T：将插入点后面的字符与插入点前面的字符交换。
Command–左花括号 ({)：左对齐。
Command–右花括号 (})：右对齐。
Shift-Command–竖线 (|)：居中对齐。
Option-Command-F：前往搜索栏。
Option-Command-T：显示或隐藏 App 中的工具栏。
Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。
Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。
Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。
Option-Command-I：显示或隐藏检查器窗口。
Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。
Shift-Command-S：显示“存储为”对话框或复制当前文稿。
Shift-Command-减号 (-)：缩小所选项。
Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。
Shift-Command–问号 (?)：打开“帮助”菜单。
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/09/21/ios%E9%87%8C%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/21/ios%E9%87%8C%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">ios里的动态库和静态库思考</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-21 11:11:50" itemprop="dateCreated datePublished" datetime="2022-09-21T11:11:50+08:00">2022-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-28 13:23:57" itemprop="dateModified" datetime="2022-09-28T13:23:57+08:00">2022-09-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="制作静态库参考"><a href="#制作静态库参考" class="headerlink" title="制作静态库参考"></a>制作静态库参考</h4><p><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/2430-how-to-create-a-framework-for-ios">制作静态库参考</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/95967d83e168">翻译</a></p>
<h3 id="什么是库？"><a href="#什么是库？" class="headerlink" title="什么是库？"></a>什么是库？</h3><p>库（Library）</p>
<p>[TOC]</p>
<h3 id="规范项目目录"><a href="#规范项目目录" class="headerlink" title="规范项目目录"></a>规范项目目录</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">|- AppDelegate    // 整个应用的入口</span><br><span class="line">    |- Category   // AppDelegate的扩展：3DTouch、OpenURL、RemoteNotification...</span><br><span class="line">    |- StartLanch // App启动后业务功能操作,使用类方法进行一些操作</span><br><span class="line">    |- SDKManager // AppDelegate中需要做的第三方SDK的配置</span><br><span class="line">        |- EHIVendorSDKDefines.h // SDK的key/appID相关数据定义</span><br><span class="line">        |- EHIVendorSDKManager   // 多个SDK的配置</span><br><span class="line">        |- EHIPushManager</span><br><span class="line">        ...</span><br><span class="line">|- Defines                // 整个应用会用到的定义</span><br><span class="line">    |- EHIMacro.h         // 必用头文件引入（YYKit.h）</span><br><span class="line">    |- EHIAppDefines.h    // App信息、UI的宏定义(字体、颜色、适配)</span><br><span class="line">    |- EHIFunctionDefines // 全局方法或内敛函数定义（EHIWeakSelf/EHIStrongSelf）</span><br><span class="line">    |- EHIEventDefines    // 统计事件使用的Key</span><br><span class="line">|- Features     // 功能模块目录     </span><br><span class="line">    |- Load     // 主页加载之前的引导页</span><br><span class="line">    |- Login</span><br><span class="line">    |- UserCenter</span><br><span class="line">    |- Home</span><br><span class="line">    |- SelfDriving</span><br><span class="line">        |- EHISelfDrivingDefines  // 枚举、提示语、数据存储Key、通知（每个模块都根据需要定义）     </span><br><span class="line">        |- Step1</span><br><span class="line">        |- Step2</span><br><span class="line">        |- Step3</span><br><span class="line">        |- Step4</span><br><span class="line">        ...</span><br><span class="line">    |- Chauffeur</span><br><span class="line">    |- OrderCenter</span><br><span class="line">    ...</span><br><span class="line">|- Tools                // 工具类、Categories</span><br><span class="line">    |- Foundation</span><br><span class="line">        |- NSArray      // Categories</span><br><span class="line">        |- UIButton</span><br><span class="line">            |- Category // Categories</span><br><span class="line">            |- UIKit    // UI类的多了个自定义控件文件夹</span><br><span class="line">    |- UI               // 除了系统类的自定义UI</span><br><span class="line">        |- UploadPhotosView </span><br><span class="line">        ...</span><br><span class="line">    |- SDKManager       // 对第三方SDK的封装（分享、加载图片...）</span><br><span class="line">    |- Manager          // 非第三方SDK的功能封装</span><br><span class="line">        |- AuthorityManager</span><br><span class="line">        ...</span><br><span class="line">|- Helpers              // 帮助类。包含网络、数据库、定位等操作类的封装和实现</span><br><span class="line">    |- NetWork</span><br><span class="line">    |- Data</span><br><span class="line">    |- Location</span><br><span class="line">    ...</span><br><span class="line">|- Vendors      // 第三方的类库/SDK。部分需要修改或者不支持cocoapod的第三方的框架引入</span><br><span class="line">|- Resources    // 资源文件。包含图片、声音、文件（.plist/.json/.ttc）</span><br><span class="line">    |- GIFImages</span><br><span class="line">    |- ProjectCer</span><br><span class="line">    ...</span><br><span class="line">|- Supporting Files    // Xcode自带文件夹</span><br><span class="line">    |- Images.xcassets // 工程默认图片存放文件夹,可以在该下按不同模块创建文件夹存放对应的图片</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>三、代码格式<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e12560a0ead2">更过规范在简书</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ssj1314.github.io/2022/09/19/iOS%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E8%BD%AC%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大福禄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="葫芦小金刚">
      <meta itemprop="description" content="书中自有颜如玉">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 葫芦小金刚">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/iOS%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E8%BD%AC%EF%BC%89/" class="post-title-link" itemprop="url">iOS主线程刷新UI的思考（转）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-19 15:42:37 / 修改时间：16:08:50" itemprop="dateCreated datePublished" datetime="2022-09-19T15:42:37+08:00">2022-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://dywane.github.io/">https://dywane.github.io/</a><br>在开发过程中，我们或多或少会不经意在后台线程中调用了UIKit框架的内容，可能是在网络回调时直接imageView.image = anImage，也有可能是不小心在后台线程中调用了UIApplication.sharedApplication。而这个时候编译器会报出一个runtime错误，我们也会迅速的对其进行修正。</p>
<p>但仔细去思考，究竟为什么一定要在主线程操作UI呢？如果在后台线程对UI进行操作会发生什么？在后台线程对UI进行操作不是可以更好的避免卡顿吗？这篇文章就是基于这样一些疑问而产生的。</p>
<pre><code>太长不看版：
</code></pre>
<p><code> UIKit并不是一个 线程安全 的类，UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</code><br><img src="https://raw.githubusercontent.com/Dywane/Dywane.github.io/master/resource/1685baecc3293040.jpeg"></p>
<h3 id="从UIKit线程不安全说起"><a href="#从UIKit线程不安全说起" class="headerlink" title="从UIKit线程不安全说起"></a>从UIKit线程不安全说起</h3><p>在UIKit中，很多类中大部分的属性都被修饰为nonatomic，这意味着它们不能在多线程的环境下工作，而对于UIKit这样一个庞大的框架，将其所有属性都设计为线程安全是不现实的，这可不仅仅是简单的将nonatomic改成atomic或者是加锁解锁的操作，还涉及到很多的方面：</p>
<pre><code>假设能够异步设置view的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自runloop的进度去改变这个view的属性呢？
假设UITableView在其他线程去移除了一个cell，而在另一个线程却对这个cell所在的index进行一些操作，这时候可能就会引发crash。
如果在后台线程移除了一个view，这个时候runloop周期还没有完结，用户在主线程点击了这个“将要”消失的view，那么究竟该不该响应事件？在哪条线程进行响应？
</code></pre>
<p>仔细思考，似乎能够多线程处理UI并没有给我们开发带来更多的便利，假如你代入了这些情景进行思考，你很容易得出一个结论： “我在一个串行队列对这些事件进行处理就可以了。” 苹果也是这样想的，所以UIKit的所有操作都要放到主线程串行执行。</p>
<p>在Thread-Safe Class Design一文提到：</p>
<pre><code>It’s a conscious design decision from Apple’s side to not have UIKit be thread-safe. Making it thread-safe wouldn’t buy you much in terms of performance; it would in fact make many things slower. And the fact that UIKit is tied to the main thread makes it very easy to write concurrent programs and use UIKit. All you have to do is make sure that calls into UIKit are always made on the main thread.
</code></pre>
<p>####大意为把UIKit设计成线程安全并不会带来太多的便利，也不会提升太多的性能表现，甚至会因为加锁解锁而耗费大量的时间。事实上并发编程也没有因为UIKit是线程不安全而变得困难，我们所需要做的只是要确保UI操作在主线程进行就可以了。</p>
<h4 id="好吧，那假设我们用黑魔法祝福了UIKit，这个UIKit能够完美的解决我们上面提到的问题，并能够按照开发者的想法随意展现不同的形态。那这个时候我们可以在后台线程操作UI了嘛？"><a href="#好吧，那假设我们用黑魔法祝福了UIKit，这个UIKit能够完美的解决我们上面提到的问题，并能够按照开发者的想法随意展现不同的形态。那这个时候我们可以在后台线程操作UI了嘛？" class="headerlink" title="好吧，那假设我们用黑魔法祝福了UIKit，这个UIKit能够完美的解决我们上面提到的问题，并能够按照开发者的想法随意展现不同的形态。那这个时候我们可以在后台线程操作UI了嘛？"></a><code>好吧，那假设我们用黑魔法祝福了UIKit，这个UIKit能够完美的解决我们上面提到的问题，并能够按照开发者的想法随意展现不同的形态。那这个时候我们可以在后台线程操作UI了嘛？</code></h4><p>很可惜，还是不行。</p>
<h3 id="Runloop-与绘图循环"><a href="#Runloop-与绘图循环" class="headerlink" title="Runloop 与绘图循环"></a>Runloop 与绘图循环</h3><p>道理我们都懂，那这个究竟跟我们不能在后台线程操作UI有什么关系呢？</p>
<p>UIApplication在主线程所初始化的Runloop我们称为Main Runloop，它负责处理app存活期间的大部分事件，如用户交互等，它一直处于不断处理事件和休眠的循环之中，以确保能尽快的将用户事件传递给GPU进行渲染，使用户行为能够得到响应，画面之所以能够得到不断刷新也是因为Main Runloop在驱动着。</p>
<p>而每一个view的变化的修改并不是立刻变化，相反的会在当前run loop的结束的时候统一进行重绘，这样设计的目的是为了能够在一个runloop里面处理好所有需要变化的view，包括resize、hide、reposition等等，所有view的改变都能在同一时间生效，这样能够更高效的处理绘制，这个机制被称为绘图循环（View Drawing Cycle)。</p>
<p>假设这个时候我们应用了我们的魔法UIKit，并愉快的在一条后台线程操作UI，但当我们需要对设备进行旋转并重新布局的时候，问题来了，因为各个线程之间不同步，这时候各个view修改的请求时机是零碎的，所以所有的旋转变化并不能在Main Runloop的一个runloop里面处理完，这就导致设备旋转之后还有一些view迟迟没有旋转。</p>
<p>另一方面，因为我们的魔法UIKit并不是在主线程，所以Main Runloop中的事件需要跨线程进行传输，这样会导致显示与用户事件并不同步。试想一下我们用我们的魔法UIKit写了一个游戏，用户如果在图片还没有加载出来的时候按下了按钮，他们就能胜利，于是我们写出了这样的代码：</p>
<p>game.m</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)didClickButton:(UIButton *)button</span><br><span class="line">{</span><br><span class="line">	if (self.imageView.image != nil) {</span><br><span class="line">		// User lose!</span><br><span class="line">	} else {</span><br><span class="line">		// User Win!</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (void)loadImageInBackgroundThread</span><br><span class="line">{</span><br><span class="line">	dispatch_async(dispatch_queue_create("BackgroundQueue", NULL), ^{</span><br><span class="line">		self.imageView.image = [self downloadedImage];</span><br><span class="line">	};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>因为我们完美的魔法UIKit，在后台执行imageView.image = xxx并不会产生任何问题。游戏上线，在你还为后台处理UI而沾沾自喜的时候，用户投诉了他们明明没有看到图片显示，点击的时候还是告诉他们输了，于是你的产品就这样扑街了。</p>
<p>这是因为点击等事件是由系统传递给UIApplication中，并在Main Runloop中进行处理与响应，但是由于UI在后台线程中进行处理，所以他跟事件响应并不同步。即使在UI所在的后台线程也自己维护了一个Runloop，在Runloop结束时候进行渲染，但可能用户已经进行了点击操作并开始辱骂你的游戏了。</p>
<h4 id="好吧，那假设我天赋异禀，把整套UIApplication的机制全都重写了，也用黑魔法祝福了我的新UIApplication，这个时候它能完美的解决线程同步的问题，这个时候我可以在后台操作UI了吗？"><a href="#好吧，那假设我天赋异禀，把整套UIApplication的机制全都重写了，也用黑魔法祝福了我的新UIApplication，这个时候它能完美的解决线程同步的问题，这个时候我可以在后台操作UI了吗？" class="headerlink" title="好吧，那假设我天赋异禀，把整套UIApplication的机制全都重写了，也用黑魔法祝福了我的新UIApplication，这个时候它能完美的解决线程同步的问题，这个时候我可以在后台操作UI了吗？"></a><code>好吧，那假设我天赋异禀，把整套UIApplication的机制全都重写了，也用黑魔法祝福了我的新UIApplication，这个时候它能完美的解决线程同步的问题，这个时候我可以在后台操作UI了吗？</code></h4><p>……</p>
<p>……</p>
<p>#####很可惜，还是不能。</p>
<h3 id="理解iOS的渲染流程"><a href="#理解iOS的渲染流程" class="headerlink" title="理解iOS的渲染流程"></a>理解iOS的渲染流程</h3><p><img src="https://raw.githubusercontent.com/Dywane/Dywane.github.io/master/resource/1685badd6f86fdb4.jpeg"><br>要回答这个问题，我们要先从最底层的渲染说起。<br>渲染系统框架<br>UIKit.jpeg<br>    UIKit: 包含各种控件，负责对用户操作事件的响应，本身并不提供渲染的能力<br>    Core Animation: 负责所有视图的绘制、显示与动画效果<br>    OpenGL ES: 提供2D与3D渲染服务<br>    Core Graphics: 提供2D渲染服务<br>    Graphics Hardware: 指GPU</p>
<p>所以在iOS中，所有视图的现实与动画本质上是由 Core Animation 负责，而不是UIKit。<br>Core Animation Pipeline 流水线<br><img src="https://raw.githubusercontent.com/Dywane/Dywane.github.io/master/resource/1685badf08f1dda1.jpeg"><br>Core Animation的绘制是通过Core Animation Pipeline实现，它以流水线的形式进行渲染，具体分为四个步骤：</p>
<pre><code>Commit Transaction:

可以细分为
    Layout: 构建视图布局如addSubview等操作
    Display: 重载drawRect:进行时图绘制，该步骤使用CPU与内存
    Prepare: 主要处理图像的解码与格式转换等操作
    Commit: 将Layer递归打包并发送到Render Server

Render Server:

负责渲染工作，会解析上一步Commit Transaction中提交的信息并反序列化成渲染树（render tree)，随后根据layer的各种属性生成绘制指令，并在下一次VSync信号到来时调用OpenGL进行渲染。

GPU:

GPU会等待显示器的VSync信号发出后才进行OpenGL渲染管线，将3D几何数据转化成2D的像素图像和光栅处理，随后进行新的一帧的渲染，并将其输出到缓冲区。

Dispaly:

从缓冲区中取出画面，并输出到屏幕上。
</code></pre>
<p>知识补充：iOS的VSync与双缓冲机制</p>
<p>VSync:</p>
<pre><code>VSync（vertical sync）是指垂直同步，在玩游戏的时候在设置的时候应该会看见过这个选项，这个机制能够让显卡和显示器保持在一个相同的刷新率从而避免画面撕裂。在iOS中，屏幕具有60Hz的刷新率，这意味着它每秒需要显示60张不同的图片（帧），但GPU并没有一个确定的刷新率，在某些时候GPU可能被要求更强力的数据输出来确保渲染能力，这时候他们可能比屏幕刷新率（60Hz）更快，就会导致屏幕不能完整的渲染所有GPU给他的数据，因为它不够快，屏幕的上一帧还没渲染完，下一帧就已经到来了，这就导致画面的撕裂。

这个时候我们就要引入VSync了，简单来说它就是让显卡保持他的输出速率不高于屏幕的刷新率，启用了VSync后，GPU不再会给你可怜的60Hz屏幕每秒发送100帧了，它会增加每一帧的发送间隔，确保显示器能够有充足的时间去处理每一帧。
</code></pre>
<p>双缓冲机制：</p>
<pre><code>双缓冲机制是用于避免或减少画面闪烁的问题，在单缓冲的情况下，GPU输出了一帧画面，缓冲区就需要马上获取这个画面，并交给显示屏去显示，而这段时间GPU输出的画面就全都丢失了，因为没有缓冲区去承载这些画面，就会造成画面的闪烁。

而在双缓冲机制下有一个Back Frame Buffer和一个Front Frame Buffer，在GPU绘制完成后，它会将图像先保存到Back Frame Buffer中，操作完毕后，会调用一个交换函数，让绘制完成的Back Frame Buffer上的图像交换到Front Frame Buffer上。由于双缓冲利用了更多显存与CPU消耗时间，从而避免了画面的闪烁。
</code></pre>
<p>So？</p>
<p>相信大家都会遇到过应用卡顿，卡顿的原因就是因为两帧的刷新时间间隔大于60帧每秒（约16.67ms），导致用户感觉点击或者滑动时，界面没有及时的响应。</p>
<p>前面提到Core Animation Pipeline是以流水线的形式工作的，在理想的状况下我们希望它能够在1/60s内完成图层树的准备工作并提交给渲染进程，而渲染进程在下一次VSync信号到来的时候提交给GPU进行渲染，并在1/60s内完成渲染，这样就不会产生任何的卡顿。</p>
<p>但是由于我们使用了我们的魔法UIKit，所以我们在许多后台线程进行了UI操作，在runloop的结尾准备进行渲染的时候，不同线程提交了不同的渲染信息，于是我们就拥有了更多的绘制事务，这个时候Core Animation Pipeline会不断将信息提交，让GPU进行渲染，由于绘制事件的不同步导致了GPU渲染的不同步，可能在上一帧是需要渲染一个label消失的画面，下一帧却又需要渲染这个label改变了文字，最终导致的是界面的不同步。</p>
<p>（如果你真的想要这样的效果，可以尝试一下使用我的DWAnimatedLabel）</p>
<p>另一方面，在VSync和双缓冲机制我们可以看出渲染其实是一个十分消耗系统资源的操作（占用显存与CPU），所以可能会因为大量的事务和线程之间频繁的上下文切换导致了GPU无法处理，反而影响了性能，从而导致在1/60s中无法完成图层树的提交，导致了严重的卡顿。</p>
<pre><code>但我真的很想在后台线程操作UI，我能再用黑魔法吗？
</code></pre>
<p>……</p>
<p>……</p>
<p>……</p>
<p>……</p>
<p>好吧，其实是有办法的。<br>Texture or ComponentKit</p>
<p>AsyncDisplayKit（现命名为Texture） 是Facebook开源的一个用于保持iOS界面流畅的框架。</p>
<p>ComponentKit是Facebook开源的一个基于React思想的iOS原生UI开发框架。它通过函数式和声明的方式构建UI。</p>
<p>让我们撤销掉我们对UIKit施展的各种魔法，回到这个UI只能在主线程进行操作的世界吧。这两个框架其实并不是真正的在后台线程操作UI，而是用了更巧妙的方法将一些耗时的操作异步执行，从而绕开了UIKit只能在主线程操作的限制。</p>
<p>比如Texture创建了各类Node，在node中包含了UIView，而Node本身是线程安全的，所以允许在后台线程对Node进行修改，随后在第一次主线程访问View的时候它才会在内部生成对应的View，当node的属性发生改变的时候，他也不会马上进行修改，而是在适当的时机一次性的在主线程为内部的View进行设置。（有点类似于绘图循环）</p>
<p>而ComponentKit则是通过创建Component来描述UI，它也是一个线程安全的类。可以将Component认为是一个刻板，而UIView是刻板下的一张纸，渲染则是喷墨的过程。当我们生成了一个Component的时候，就等于生成了一个View的模版，在进行渲染的时候只要按照模版进行绘制就可以了。复杂的界面可以通过各种简单的Component来组成。（类似于Flutter的widget）<br><img src="https://raw.githubusercontent.com/Dywane/Dywane.github.io/master/resource/1685baecc3293040.jpeg"></p>
<pre><code>但是我……
</code></pre>
<p>闭嘴吧你<br>总结</p>
<p>UIKit不能在主线程进行操作，这一个铁律只要是熟悉iOS开发的都会有所耳闻，但是往深一层其实这个涉及到很多的东西，包括软件、整体UIKit框架的实现、硬件等等，很多细节的东西往往是我们在平常有所忽略的。可能我们知道不能在主线程操作，却不知道其内在原因；可能我们知道怎么排查、处理卡顿，却不知道其真正的成因；可能我们知道drawRect:方法会导致CPU飙升，却不知道原因是上下文的切换导致……</p>
<p>写代码从来都不是一件简单而显而易见的事情。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大福禄</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
